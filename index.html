<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="ProjectBIOS : Three students' attempt to design and implement a BIOS for the Raspberry Pi" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>ProjectBIOS</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ProjectBIOS">View on GitHub</a>

          <h1 id="project_title">ProjectBIOS</h1>
          <h2 id="project_tagline">Three students' attempt to design and implement a BIOS for the Raspberry Pi</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>Welcome to Jacob Deines's Capstone Blog</h1>

<p>This website will be my attempt to track our progress throughout the process of building and designing a BIOS system for the Raspberry Pi. Our team consists of three members, Josh Nelson, Dan Case, and myself. This is a student project at PLU for our capstone class. Our faculty mentor is Dr. Kakar. Our project website can be found at <a href="http://biosproject.github.com/biosRepo/">biosproject.github.com/biosRepo/</a>.</p>

<h2>Our Plan (ORIGINALLY)</h2>

<p>Our plan is to design and implement a Basic Input Output System (BIOS) tailor-made for the Raspberry Pi. The Raspberry Pi uses an ARM processor, so we are still working on if our plan can be implemented as is. If not, we may have to switch to another small system. We are still in the preliminary stages of our research and conceivably will not know for certain if it can be done until we attempt it. For now, we are gung-ho and are excited to try something new and different!</p>

<h2>Benefits</h2>

<p>The potential benefits of this project are many. The first of which is that is is different from the typical project at PLU. Many projects are solely based in high-level coding and design, whereas our project aims to reach through to the lowest levels of abstraction. This experience with low-level coding is a major advantage in the workplace, because it helps us understand and interpret what goes on at a higher level. This understanding gives us an edge when running into problems of design or implementation. We will better understand how software and hardware communicate, potentially revealing previously unseen ways to better our code.</p>

<h2>Timeline (ORIGINALLY)</h2>

<p>Our time line is obviously tentative, as is the hallmark of software development. However, we plan on meeting the following dates with these goals in mind:</p>

<ul>
<li>September: We have been hard at work conducting research and planning</li>
<li>October:   We plan on having our requirements document finalized</li>
<li>November:  Our plan is to have completed at least preliminary function testing on the Raspberry Pi</li>
<li>December:  Our project plan should be finished and we should be starting implementation</li>
<li>January:   We hope to have implemented our BIOS POST (Power On Self-Test)</li>
<li>February:  Implement hardware configuration</li>
<li>March:     Nail down boot-strapping</li>
<li>April:     Complete development and testing of our BIOS</li>
<li>May:       Present our project</li>
</ul><hr><h1>Blog</h1>

<h2>3/30/2013</h2>

<p>This week was spring break at PLU, but there was not a lot of breaking going on here. The whole week I have spent working on this project and trying to iron out the kinks while I have less to focus on. I talked with Dr. Wolff about some of my issues with Django over the week, and we decided to not worry about a web framework just yet. For now, and for most of the week, my goal has been to get SCP working between a client and a host machine, then automating that. Once I have that integral function complete, I will then work on setting up a website to host the images stored, and lastly adding user authentication to that.</p>

<p>My issues with Django were unfortunately numerous. The were mostly stemming from a lack of knowledge of its internal structure and not knowing the correct syntax. I could not get pages to redirect properly, and I couldn't figure out how to set up user authentication with the existing user database set up when first making a project in Django. I researched but hadn't touched file storage or retrieval, and trying to get logic to work was really a pain. Because of all these issues, and given the time frame, I figured it was best to build my own server and host images at the most basic level I could. The new plan with the website involves setting up a server as simply as possible, and having only a couple of pages to deal with. Logic would be done through PHP and a MYSQL database.</p>

<p>About getting SCP up and working, I have already crudely accomplished this. After some initial setup, I can run an SCP command through a python script and have the file end up where I want it to go. The problem is that there is rather a lot of setup that goes into making it work. For our purposes (uploading a file to the server), each client machine will need to become its own "server". More specifically, if a client machine wants to send (serve) information to the server, it needs to have openssh-server and openssh-client installed. Furthermore, each machine has to generate an RSA encrypted passcode to use so the machines can send information to each other without prompting the user for a password. This passcode then has to be sent to the other machine via SCP or ssh and stored locally on that machine. To do that, you need the password for our server. We can get around having the server know other machines' passwords by installing the passcode directly when installing our program, but when clients register their machines, the only reasonable way to get their passcodes onto the server is to use scp to get it on there. Following me still?</p>

<p>Now, this should be all fine and dandy because we can automate scp, and even touch on regular input. The problem comes about whenever a password field is needed. Password fields are treated differently than other input fields, so the python library I am using does not work with it. Security-wise, that's a good decision; for me, a very frustrating problem. I found a workaround using an external library called "pexpect", which spawns a child process and interacts with it in a similar fashion to what I am already using, but it can input to password fields. I even got it to work with a simple prototype that opens an ssh shell. However, it is failing when I try to make it do nearly the same thing in the installation program I'm making. I can't quite pin it down, but I think it's either a problem with multiple processes, or a buffer issue.</p>

<p>What happens is pexpect spawns the program and then waits for (expects) input that gets searched using a regular expression. Once it finds what it's looking for, it can then reply with a string input. I have it set up so that the regular expression looks for the password prompt, then replies with the server password. Sometimes it works, other times it doesn't. If it doesn't work, it opens up a window that prompts for the password, then closes. If I input the password there it works, but overall, that defeats the purpose of automating it. I am making sure to keep the environment the same (no keys from the same machine already in the log which would cause it to not prompt for a password), but it still acts erratically. When using some native variables for error checking, I can tell that sometimes the regular expression reads the first part of the prompt, and other times it reads the last part, but sometimes it doesn't read any. The developers claim that this erratic behaviour can be caused by "chunks" arriving erratically due to buffering. However, there is no mention of how to fix this, increase the buffer size, wait for the whole thing to load, etc. so I'm stuck. I have tried using timing and checking for multiple regular expressions, but I can't get it to work. I'm very close to success with the SCP beast, and if all else fails I can move to the web and server design and just require some initial setup from the user, but I would rather installation be secure first.</p>

<p>I have not heard from Dan this week, but Josh let us know that he has OpenCV working and can pull images from the camera, which is great. He expects to be done with the library soon, and can then work on getting the client app up and running, as well as helping Dan and me out a little. That's all for now, cheers!</p>

<h2>3/23/2013</h2>

<p>This week has been about design and setup. We have hashed out our class diagrams a bit more and built up our use cases. During this process, I was doing research into what programs and frameworks I should use to build the server side. After talking with Dr. Wolff about it, I am going to stick with Django as a web framework. It is written for python development and is a very powerful tool that will add complexity to the project. However, as Dr. Wolff mentioned, there is a steep learning curve with frameworks. I am just about done running through the basic tutorial that Django has published for users to learn their framework. It's a bit convoluted at times, but I am getting the basic idea and trying to apply it to my own code. Since Django is just a web framework and not a server framework, I may need to install Apache and use that to set up my server. At the moment, this is not ideal because it would add another steep learning curve that I don't know if I can fit in to my schedule. The current solution is to use Django's development server until I have time to implement either my own bare-bones server, or to integrate with Apache.</p>

<p>Along those lines, I have been tinkering with building my own basic echo server and client-side. The idea was to get a better feel for what the server has to do and how the client will communicate with it in python. An interesting note is that I cannot implement a multi-threaded server with python. This is because of the Global Interpreter Lock (GIL) that runs only one instance of the interpreted language. There are ways to "get around" it, but none I have tried so far work. This could be a significant problem because the server will not be able to take in server commands while it is listening for connections, which is obviously poor server behavior. I am looking into whether or not Django has support for multiple threads or if that's an Apache thing, and I will have to find a workaround until then. My feeling is that Apache is the one that supports multi-threading, and if that's the case, I may have to write the server in another language until Apache can be used. If that's the case, I may write it in Java or a variant of C, since (if memory serves) python is written in C, or at least integrates well with it.</p>

<p>As far as transferring files to the server, after talking with Dr. Wolff again, I should definitely use SCP to transfer files, unless it can be done more easily with HTTP or Django. I keep learning about new features in Django, and file transfers and file system storage seem to be things Django works with. If this is the case, it could be good because I will not have to have so many pieces of the same server floating around; they can be all in the same area. However, it could also be bad if I do not get Django up and running soon. I am hard at work learning the syntax and structure of Django, and hope to have at least a good majority of it up by the end of Spring break.</p>

<p>I have not spoken much to Dan or Josh about the progress of their projects, but from what I understand, Josh has compiled and started working with OpenCV to pull pictures and/or video from the webcam. Since OpenCV is such a large and comprehensive program, Josh is looking into how it pulls the files from the webcam and seeing if he can produce the coding for that part only. Otherwise, we might have to install OpenCV on each client computer, and that would not be ideal. If he doesn't run into any problems, he should be done with this section soon and I have asked him to help with some of the server side if he has time. If Dan has trouble, he might help Dan instead. Dan seems to have been pretty busy this week with his job, and so did not get much done. For Spring break, he has taken the RPi and the PIR to get that set up. My expectation is that he will have that all done by the time he gets back so we can hook up what he already has to the Raspberry Pi Cobbler kit I bought, and we will be able to see the PIR signalling to the RPi. That's it for this week, have a good Spring break; cheers!</p>

<h2>3/15/2013</h2>

<p>After last week's disappointment, this was the week to get it all sorted out. Throughout the week Josh and I discussed our options and what our next project would be, or even if we could continue on with the project we originally started. I personally wasn't too attached to the idea of slogging through and making the BIOS idea work. Though it would be a very satisfying accomplishment to finish what we started, I honestly didn't think we would have the time or drive to pull it off. On Thursday we met up with Drs. Wolff and Tosh to discuss the next steps. After some deliberation we settled on a few different options:</p>

<p>Option one, we continue with the original project idea and do our best to complete it in the remaining time we have. If we don't finish in time, we could make it an "incomplete" and finish it over the summer, at the cost of our degrees until then. For obvious reasons, the incomplete idea is less than preferable.
Option two, we focus on getting the JTAG working and get some binaries written and running on the RPi, but no significant code base. While this is an appealing proposition, it doesn't quite work because there would not be a significant enough portion of code to qualify as a Computer Science capstone.
Option three, we all split ways completely and come up with our own projects that may or may not use the Raspberry Pi. As a group, we shied away from this idea, because the resulting products from three completely different projects would not be nearly extensive or impressive enough for a capstone.
Lastly, we could start on a new project as a team that used the Raspberry Pi as a micro-controller. We would also need to utilize the capabilities of the RPi more thoroughly. This is the plan we are currently sticking to.</p>

<p>Our plan now is to use a passive infrared sensor (PIR) as a motion detector and webcam in tandem to detect and document when someone enters a space that nobody is scheduled to be in; sort of a pseudo security suite. The way we plan to implement it is that the PIR and webcam will be attached to the RPi and when the PIR is tripped, the Pi will pull a series of pictures or a video from the webcam and send it to an online database that the user can access. Then the RPi will send an alert to the user, by email or google chat or both, letting them know there was an intrusion and provide a URL for them to access the uploaded data. From the website, the user can download pictures, and possibly modify settings like their schedule or their preferred method of communication.</p>

<p>We split this project into three distinct and separate components, one for each of us respectively. I will be handling the server side, which involves a user database, the web front-end and back-end, storing and displaying uploaded data, and communicating between client machines and the server. Josh is working on the communication between the webcam and the client, and making libraries for easy communication between the client program and the hardware. Dan is setting up the PIR with the Raspberry Pi and working on the client portion of the program that will communicate to the user with google chat and email, as well as communicate to the server.</p>

<p>There will be a document, similar to a proposal document and requirements document mixed, that we hope to have ready before next week. This will include class diagrams, use cases, sequence diagrams, a detailed timetable for each portion of the project, and of course a written explanation of what we intend to do, why we want to do it, and how we think we can implement it. Until then, here are some things about my portion that I am working on. For web frameworks, I was originally going to use Ruby on Rails, but my preliminary research showed comparisons of ruby and python rather than the integration of the two. I am still debating on using one, but my current preference is to use Django. It is a web framework used with python that seems both user friendly and comprehensive. I would prefer to use a web framework because I have no experience with any yet and doubt many companies build their websites without one, therefore it would be good experience to know at least one. Most of the scripting will be done in python as well. Since much of the coding for hardware components will be done in python, it will be an easier transition between classes and across networks. In short, using python all around avoids conflicts. As far as I can tell, Django and python use SQLite3 out of the box, so I see no reason in changing to a more complex database management system. Direct communication between the client and server will be facilitated by a straight-up socket and some data transfer protocol, most likely ftp or scp. I don't know which yet, but I will be looking into it soon as it is a major aspect of the project. The ftp/scp will handle uploads to the server, and the socket will handle all other communications.</p>

<p>I have also started on some rudimentary designs for our project. We are still working out the kinks, but in general we have a sense of what classes need to exist and how the data will flow. I am coming up with UML classes for the whole thing right now to give myself a better overall view, but will very soon focus down onto only my portion of the project design. I have also made one sequence diagram so far, and intend to make more as soon as I finish up with my use cases. Currently the design is to have a client program on the RPi that will act as a standalone unit if the server is down. This also sets it up for scalability. The client program will handle all notifications and personal information about the users on its own, but will upload the pictures to the web so they are more accessible. If the server goes down, the client program stores pictures in the file system until the server is up and running again. If the number and size of files exceeds a maximum set, then the oldest data will be deleted automatically until enough space is freed.</p>

<p>I am concerned with the amount of effort my group members are willing to put into the project. I fully believe that they want to receive a good grade on this and come out of it with a solid product, but I don't think they are heeding Tosh's advice to stay and bust our butts through spring break. Both Dan and Josh have indicated they will be traveling but available and working. But if J-Term is any indication, I could see a problem arising. Without a doubt, Dan was most passionate about continuing on with the BIOS project; when we decided to move on, he indicated to Josh and I how upset he was. Though he appears to be "over it" and is now all for the new project, I have a nagging fear that this could affect his progress. Josh has been overwhelmingly helpful in coming up with the design of our new project. Over the course of several hours, we went from having no plan at all to a pretty solid idea of what to come up with, including where to get parts, what parts we would need, and a couple rough sketches of the design. However, as I mentioned before, Josh plans on traveling over spring break and it becomes hard to maintain communication with him when we aren't meeting regularly. I trust him to complete his part of the project, and I understand the circumstances leading to his travel (as well as Dan's), but I am just hoping they are as dedicated to the project as they need to be to have a fully developed product.</p>

<p>Hopefully this new project will be approved and we can get started right away. I am much more excited about this project than when we started losing direction, and would love to see a final product come to fruition. Thanks for reading, cheers!</p>

<h2>3/8/2013</h2>

<p>Bad news. After an enormous and exhausting amount of research, we are still at a standstill on our project. Hooking up the Raspberry Pi to openOCD has been plaguing us for some time, and the only evidence that it has been done before is a very poorly documented github repository by a gentleman who managed to make it work with a lot of finagling, bit-banging, and use of a hardware component we can neither afford nor get on time. We looked through and tried to modify as much of his code and setup as we could, but we simply haven't gotten it to work yet.</p>

<p>Josh has spoken with Tosh and Dr. Wolff about what we need to do to fix this. As I understand it, we will continue writing our detailed reports for Tosh, John, and Dr. Wolff to see, and discuss what needs to happen next once they have had a chance to see what we have done and learned. At this point, it is looking like we are going to have to change our project. Initially setting up the JTAG and having it interface with openOCD was pitched, but it rings more of a computer engineering project than a computer science one. It needs to be a significant piece of software. We will discuss our options this weekend when we reconvene.</p>

<p>This comes as a great disappointment to my group mates and me, as we were really setting our hopes on making this project work. Investing so much time and effort into something that turns out is near-impossible for us to do in the amount of time we have and with the limited resources we have is discouraging. We will definitely do our best and explore our options as best as we can before completely copping out, and it's important to note how dedicated we all have been to this project. Nevertheless, what has happened has happened, and the only direction to go is forward. I am looking forward to what the future has in store, and hopefully we will still have a major product we can be proud of. That does it for now, cheers.</p>

<h2>3/1/2013</h2>

<p>This week we got together and met with John Schock here at PLU. He was invaluable with his help and we are in the process of seeing if this can become a regular thing. As of right now, we have our Raspberry Pi hooked up to a bread board so we can use the ARM JTAG to start debugging. All we have left to do there is stick the right wires in the right places on the JTAG and configure it with OpenOCD, then we should have a working debug solution.</p>

<p>As for outputting to the screen, we have a conundrum: we can either stray away from the "bare-metal" idea and use ncurses, which is a very useful library for the creation of text UIs, or we can try to stick with the bare-metal and try to output to the screen directly. On an ARM system, we do not have the video buffer at a simple memory address, as I mentioned last week. Instead, ARM uses a system they call the mailbox function to send and receive messages directly to and from the CPU. According to my research so far, using the mailbox to display output to the screen is possible, however difficult. It is my preference that we stick to using ncurses for now, and if we have time we can implement a lower-level approach.</p>

<p>We almost have our software toolchain all set up as well. Currently, we are configuring and testing BerryBoot on the RPi, so we can look and see how it boots into one kernel and can switch into another. We are also working on other softwares at the moment (RPi-buildroot and ncurses among them), to help with actual development. We are very near completion of this setup and I am very excited to get it all up and running so we can test our code directly.</p>

<p>Our project is now very different from where we started. As I alluded to earlier, we will basically be booting into a very lightweight kernel containing our own code. As the RPi boots up, it will first move to our code, show the keyboard interrupt command, and if the key remains unpressed, our kernel should hand off to the OS kernel, where it will resume normal boot operation. If a user hits the key to enter BIOS settings, our text UI (at this point run using ncurses, supported by other libraries) will appear and provide a menu to modify settings, then restart the RPi with those settings.</p>

<p>Josh and Dan are both working hard to get things done, and we are making good progress. Josh is mostly working on setting up the hardware at this point, and Dan is working on the toolchains, mostly centered around OpenOCD. I am researching how to output to the screen, as well as getting the keyboard interrupts and managing the pathways our data must travel at such a low level (i.e. mailbox function). In our last meeting with Tosh, we were asked to document, in as much detail as we can, the discoveries we make and send them to him bi-weekly along with our current blog entries/project updates. That's it for now, next week we should have the hardware and software toolchains set up so we can start coding. Until then, cheers!</p>

<h2>2/22/2013</h2>

<p>Hello again, everybody! It's been a long while since my last post, so there is a lot to go over. As you know, the scope of our project has narrowed. This is good. Over Christmas break and J-Term, we worked on the project individually. Attempts at communication were met with silence. This is bad. However, as we got back and met up again, good things came to light. First and foremost, we now have our Raspberry Pi and it is up and running with Arch Linux ARM. We also have the ARM JTAG, which will help us program and examine processes on the Pi. Preliminary testing is showing promising results as we have a piece of prototyped code that we can insert into the boot sequence, which should be able to execute our code before the RPi boots into the OS. Thanks to Josh for finding the code and for buying the RPi with all its peripherals.</p>

<p>I have been working on getting our program to display to the screen. According to my research, most monitors have their own BIOS and hardware, which allows them to switch states between a "regular" graphics mode to "text" mode. Text mode works like a terminal screen, and is the screen mode when one sees the blue screen of death. To access that mode, all we need to do is send a command in Assembly to the CPU telling it what to do and then execute a specific interrupt that tells it to apply this action to the screen. The only problem with this is that it requires the processor to be in "Real mode" to work. Real mode is the first mode of all Intel x8086 chips (as far as I can tell) and is basically a 16-bit mode that enables the BIOS to perform its functions more efficiently. After the BIOS is done setting stuff up, the CPU switches from real mode to "Protected mode", where most computing is done.</p>

<p>There is, however a way around this. I haven't gotten it to work yet, but I have code examples and information that points to some C with inline Assembly (or just straight-up Assembly) that will initialize the right registers and set the screen to text mode. I am concerned, however. As the chip on the RPi is not x8086 and is in fact RISC, there is a good possibility that some of what I am learning is different, or worse, not used at all. I assume the registers and Assembly will be similar enough to figure out, but I have my doubts as to whether the Broadcom chip has a similar 16-bit mode. Also, the screen already displays information at the point of our interrupt, so we might get lucky and not need this snippet of code in the first place. If that is the case, we will simply need to write what we want into the video buffer (found at x8000 from my research, also might be different on RPi) and we have video output! There are also hints of tools we may be able to use that will help design a "Text UI" (think more complex than command line, less complex than GUI), instead of having to hard-code all that in. Certainly there is more research to come on this.</p>

<p>I have also been looking up how to write interrupts. So far I have made the distinction between Interrupt Service Routines, Interrupt Handlers, and Hardware Interrupts. It seems each one is distinct and integral for creating a successful interrupt. However, just like earlier, I don't know if they will be necessary, seeing as we have already inserted a file that pauses the current booting sequence until our code is done running. It may be necessary to write them anyway, as we still are not 100% on whether or not we will have access to the keyboard. If we do not, we will have to hand-write all our interrupts and interrupt handlers. If we do have access to the keyboard, we will still at least need to know how check to see what keys are being pressed and how to interact with them.</p>

<p>Dan has been hard at work researching the toolchain to use and what software we will use to develop some of our testing code. He is currently attempting to acquire the necessary resources and get them set up on the lab computers. Josh is working on getting or prototype file, blinky.bin to work fully. This is a binary file he found on GitHub that will theoretically pause the boot process, blink LEDs on the RPi, and then resume normal operation. Josh has been in contact with the author and is awaiting more information to see where this lead can go.</p>

<p>As a group, we will hopefully meet up with John Schock in person either on Saturday or in the very near future. This is very exciting for us because we can finally relay all the information we have in a face-to-face encounter and get him fully caught up to speed. Until next time, cheers!</p>

<h2>12/7/2012</h2>

<p>I missed last week's post due to a swim meet. Sorry about that. Anyway, I have a lot to fill in. First, the scope of our project has changed drastically as of two weeks ago. We found out that much of the init code on the Pi is proprietary, so we can't touch it. What happens is this: when the power is turned on, the Broadcom chip's on-board ROM outputs the memory address of two files on the SD. The first file is the bare-metal init code. This is stuff we didn't want to mess with anyway. The other file is called "start.elf". This file performs the POST and hardware initialization. It in turn points to three files: commandline.txt, config.txt, and kernel.img. The commandline.txt file is at this point somewhat of a mystery, but we assume it is basic code to show what is output to the terminal screen while the hardware is initializing. Kernel.img is the compressed kernel image that loads the linux kernel and booloader so the Pi can make it to the OS. What we are interested in now is that config.txt file. Config.txt holds all the configurations for the hardware, and is essentially what we want to be able to edit.</p>

<p>Our plan now is to send an interrupt call during the boot process, possibly by making a call to our own code in the config.txt file, and executing a GUI that allows users to edit some of the system settings in the config file. In essence, we are stopping the boot process before the bootloader has a chance to kick in, and adding BIOS functionality to the existing RPi EFI boot process. I don't believe we have informed John Schock about this yet, but my goal is to get either Dan or Josh or both to also open up dialogue with John. We all have different questions about our different areas of research, and I believe it would be more beneficial if they relayed that information to him directly, rather than explaining it to me first.</p>

<p>Other than my above attempts at getting my partners to speak to John, I have no complaints. Both are very hard-working and as a trio we tend to be very good about informing each other of what's going on if one of us missed something. Personally, I feel that we are working well on this project and am glad that our scope could be narrowed. It would have taken an incredible amount of work to just get the hardware initialized, and that wasn't even a major part of our project! Now that we have less to worry about, we can buckle down, focus on what needs to be done, and do it.</p>

<p>Our Pi should be coming any day now, and then we will finally be able to tinker with it and start prototyping. What I really want to nail down first is the interrupt call. I feel like we need to know how those work, how to implement them, and when we will be able to do so in the boot process. Another concern is how we will get the GUI running. We are not sure which C libraries will be available to us when the program is compiled (using a toolchain and cross-compiler), which means we don't quite know how hard it will be to set all of that up. After that, I/O will be the next task. To create and edit files at such a low level may prove to be very difficult. I suppose we will just have to wait and see. In the meantime, more research, more books!</p>

<h2>11/23/2012</h2>

<p>Happy Thanksgiving, all! Hope everyone had a good time. This week was academically short (as far as work is considered). I made sure to grab and continue reading "Embedded Linux Primer" and have mainly looked over chapter four this week. Chapter four contains information about kernel configuration and other various low-level settings. Using the "make" function, we can build a kernel if we need to, or build ELF files. I am continuing to take notes and post them on a google doc to be shared with the group.</p>

<p>We will meet with Tosh on Tuesday to look over the graded requirements document. We are also in the process of setting up a meeting time with John Schock at the Intel plant to get an in-person meeting. Other than that, there is not much more to report. Cheers!</p>

<h2>11/17/2012</h2>

<p>First, it's apology time! I have not posted in a short while. These past couple of weeks have been almost completely research based. Josh, Dan, and I are meeting consistently (finally) on Tuesdays and Thursdays from noon to one, which has been very helpful in updating each other with info. Preparing for the upcoming break, each of us has grabbed a book from our collection with the intent on reading it, taking detailed notes, and presenting our findings to the rest of the group. That way we can get through three books in short order.</p>

<p>We continued our search for a bootloader, and found out that the Arch Linux ARM distribution we plan to use implements Das U-Boot. This is very fortunate for us because "Embedded Linux Primer" by Christohper Hallinan discusses in detail the use of Das U-Boot in embedded devices. I am currently reading some preceding chapters and am finding it to be a very good resource. I believe Josh took (or plans to take) one of our books that goes into some depth about the Linux kernel, and Dan will be taking our book on ARM 11.</p>

<p>Correspondence with John has been going well. We had not replied for a while because we did not have questions or, at least, didn't know how to ask the questions we had due to lack of research. We are still waiting on our RPi and will be ordering the ARM JTAG soon. We did not order it right away because we were not sure what it could do or if it would be all that much help; however, a quick explanation by John has be convinced that it could be integral to our project development. One concern is that we will need to change around the GPIO pins on the Pi itself to configure it correctly.</p>

<p>So far, I think we are doing well with time management as a group, but I think we could all do better. I personally have a hard time getting in to the workroom when I don't know what exactly I will be researching, but being there heads off a lot of distractions, and I usually get some good research done. Soon, we plan to meet up in person with John, provided we can all find a suitable time. I think that an in-person meeting would be invaluable when making decisions and acquiring information quickly.</p>

<h2>11/4/2012</h2>

<p>This week was fairly laid back. We got together a couple of times for research, and mostly found more issues that we need to solve, such as finding a compatible bootloader and how to build project files. We ordered a Raspberry Pi kit that includes the Pi, a case, charging cable and SD card. Buying the components individually would have ended up costing more. We are continuing to correspond with John Schock and Tosh has informed us that he will ask John to be a professional mentor, since has been so eager to help us out so far. We have started a research plan for our printed resources. One person takes home one book, reads as much relevant information as possible from it, takes notes, and then shares those notes with the group. That way we can get through several books much faster, and have a good idea of the information in each. All group members are working well together, and we intend to make the best of this long bit of unstructured time. Filling our time with research (especially when we have the Pi in hand) and prototyping will be very helpful.</p>

<h2>10/27/2012</h2>

<p>On Wednesday I went to the library to research for more books. I ended up with five, most of which simply provide an overview of bootstrapping or an explanation of what a BIOS is. However, I found two books which could be of great use, as they have whole chapters on the boot process. All of the books I collected were coincidentally about the Linux kernel, which is actually more helpful than harmful considering the operating system we plan to boot to is going to be a Linux distribution. We finally got to correspond via email with John Schock, and we are finding out that we still have a lot to do. For debugging, we are still working out the kinks, but as we understand it, the ARM JTAG debugger works for our purposes, and we could also use VirtualBox on Linux machines so we have a virtual machine. Mr. Schock suggested that we turn our development more toward an EFI (Extensible Firmware Interface) boot on top of the existing init code for the SoC chip. Otherwise, it would require a lot more work and some legal finagling to continue.</p>

<p>Most of our week was spent working on the Requirements Document. I can say that by the end, we were all exhausted, frustrated, and much more thoroughly knowledgeable about our own project. I did have one complaint, which I expressed in rant form to Josh and Dan earlier in the week. I was frustrated because we were not getting our documents in to Tosh to review. The response I would get when I would suggest it, was that the document was unpolished enough to send to review. I explained that Tosh is a valuable resource and by cutting him out of our project (because our draft was still a draft) was subversively hurting us as a group. Now that we have all discussed it, however, I hope this will no longer be a problem.</p>

<p>As a team, I was surprised at the amount of accountability we had with each other, considering that the past couple weeks were much less structured. Every time we planned to meet up, we would text one another and make sure they were on their way. Josh helped out from home, which is great, and even stayed late on Thursday night, which can be a drag when having to drive so far. Dan's hectic work schedule got in the way a bit, but overall he was there when he was needed, and really helped pull together some of the major sections in our document. Overall, I think that we are on an upswing that will put us closer to the right track, and on time for completing our BIOS. Cheers!</p>

<h2>10/19/2012</h2>

<p>This week has been mostly focused on creating our Requirements Document. We have mostly been working on it through the Google doc and not in person, however we did meet up with Tosh and determine where we think we are on the project and the Requirements doc. We are still looking for more resources, most of which are either too detailed, or focused mainly on things we don't need to look at. Josh and I found a good couple of sites that have open source BIOS projects, but most are either incomplete or are a sort of amalgam of different softwares and firmwares. I downloaded the repository from one of them, called Coreboot, which I hope will help when we look through their code. So far as I understand it, the Coreboot system works by performing the necessary hardware initialization (which is what we are mainly interested in right now), then loads "payloads" which appear to be different bootstrapping programs. According to their wiki, the Linux kernel can be loaded payload free, so that is probably what we want to look at more in depth.</p>

<p>Our group is doing well, and now that I have no more PE classes, I have more time to work on things. Josh and Dan are both doing well and it appears they are making headway on their contacts. I have personally contacted Dillon Mark and asked him to see if he could forward us John Schock's information so we could get a hold of him. I am hopeful that we actually get to directly correspond with Mr. Schock soon.</p>

<h2>10/12/2012</h2>

<p>We now have a book from Dr. Crocker (thanks to Dan for that) about the ARM 11 architecture, which has some good stuff in it. Currently, we are still reviewing it, so there's not a lot of knowledge to throw down just yet. We also got more set up in our workroom. Meeting with Dr. Kakar on Wednesday was definitely valuable. He suggested that we meet up with Dillon Mark, who graduated last year and could be of some help, and John Schock, a BIOS engineer at Intel and alumnus of PLU. Josh has started posting on the Raspberry Pi forums, looking for advice, and I am trying to track down an email for Mr. Schock that is not linked with his LinkedIn account, considering I don't know how reliable that is to contact him. If by Saturday I can't find one, I'll shoot him a message over LinkedIn and see if he can be of help. We are also still planning on contacting Raspberry Pi directly and seeing if we can talk to someone there. Some issues we haven't worked out yet, there's no CMOS (I'm pretty sure it's CMOS) on the Pi itself, which means that the hardware must somehow already be configured to look at the SD card for all the necessary boot information before the BIOS loads up. We are currently looking into how that works.</p>

<p>Josh and Dan are both working hard, and with Dr. Kakar's help, I think we have a legitimate chance of pulling this off. After next week my schedule will open up considerably, and we will have a good amount of time in the mornings to work on capstone in our workroom. On Saturday, Dan and I are meeting up on Saturday and Josh will telecommute via Skype, so we can work more on our Requirements Doc. I plan on reading as much as I can about the ARM 11 until then (and during) and researching as much as I can about the exact process a computer goes through during BIOS. Our plan is to get a rough draft to Dr. Kakar by Thursday for him to look over, then revise, revise, revise until we have to turn it in. Cheers!</p>

<h2>10/4/2012</h2>

<p>Our group has set up regular meeting times, and we have our meetings with Prof. Kakar planned out. We are still working on our requirements document, and have hashed out a lot of potential problems with our project. We are still gathering resources at this point, but we are getting some literature going, as well as web articles. Since Raspberry Pi as a company is focused on education, we plan on attempting to make contact with them and see if we can correspond with someone, either short term or (preferably) long term.</p>

<p>As a team, I think we are working well. We just recently got our schedules together to coordinate meeting times more efficiently, and encountered an age-old problem: It's hard to meet up when we all have different schedules. Currently, I have the hardest time fitting things in to our meeting times. As a result, I feel as if I am not doing my share of work, but am still focused on email correspondence and meeting up whenever possible. After mid-semester break, I will have much more free time, and our group should hopefully be able to meet more easily.</p>

<p>Both Dan and Josh are working diligently. Josh lives pretty far away from school, so it's also hard meeting with him, but he is doing a great amount of research for us and has found some really helpful sources. Given his previous experience with lower-level programming, he is finding things I personally hadn't even considered looking for. Dan is also working hard; he and I meet up fairly regularly because we share another course. Dan's knowledge of circuits has come in handy in looking up the hardware configurations for the Raspberry Pi, and we've been able to make some pretty surprising discoveries because of it. Cheers!</p>

<h2>9/25/2012</h2>

<p>This is my first blog post! Not much to report, but we are starting some good preliminary research and are making some headway toward our requirements document. So far scheduling times for all three of us to meet has been difficult, but doable. Cheers!</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
